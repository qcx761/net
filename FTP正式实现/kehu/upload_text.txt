#include <iostream>
#include <string>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netdb.h>
#include <vector>
#include <sstream>
#include <algorithm>

using namespace std;

// FTP服务器配置
const string SERVER_IP = "127.0.0.1";  // 替换为你的服务器IP
const int CONTROL_PORT = 2100;        // 控制连接端口

// 辅助函数：发送命令并接收响应
string send_command(int sockfd, const string& cmd){
    if(send(sockfd,cmd.c_str(),cmd.size(),0)<0){
        cerr << "Error sending command: " << cmd << endl;
        return "";
    }

    // 接收响应
    char buffer[1024];
    string response;
    ssize_t bytes_received;
    while((bytes_received=recv(sockfd,buffer,sizeof(buffer)-1,0))>0){
        buffer[bytes_received]='\0';
        response+=buffer;

        // 如果响应以 "227" 开头（PASV模式），需要解析端口号
        if(response.find("227")==0){
            break;  // PASV响应可能跨多个recv调用，但通常一次足够
        }
        // 如果响应以 "226" 或 "250" 开头（操作完成），可以停止
        if(response.find("226")==0||response.find("250")==0){
            break;
        }
    }

    if(bytes_received<0){
        cerr << "Error receiving response" << endl;
    }

    return response;
}

// 获取IP和端口
pair<string, int>parse_pasv_response(const string& response){
    size_t start=response.find("(");
    size_t end=response.find(")");
    if (start==string::npos||end==string::npos){
        cerr << "Invalid PASV response format" << endl;
        return {"", 0};
    }

    string ip_port_str=response.substr(start+1,end-start-1);
    vector<string> parts;
    stringstream str(ip_port_str);
    string part;
    while(getline(str,part,',')){
        parts.push_back(part);
    }

    if(parts.size()<6){
        cerr << "Invalid PASV response format" << endl;
        return {"", 0};
    }

    // 解析IP地址
    string ip=parts[0]+"."+parts[1]+"."+parts[2]+"."+parts[3];
